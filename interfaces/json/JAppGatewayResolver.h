#pragma once

#include "../IAppGateway.h"

#include <core/JSON.h>
#include <plugins/JSONRPC.h>

namespace WPEFramework {
namespace Exchange {

/*
 * Minimal JSON-RPC wrapper for IAppGatewayResolver used by the plugin/AppGateway.cpp.
 *
 * In upstream builds this file is generated by Thunder's JsonGenerator. In this repo we
 * provide a small, test-focused implementation so L0 can:
 *  - Initialize successfully (register "resolve")
 *  - Invoke "resolve" via PluginHost::IDispatcher
 *  - Exercise bad-request paths deterministically
 *
 * Supported request shapes (both appear in this repoâ€™s tests):
 *   A) Legacy/top-level fields:
 *      {
 *        "requestId": 1,
 *        "connectionId": 2,
 *        "appId": "com.example",
 *        "origin": "org.rdk.AppGateway",
 *        "method": "device.name",
 *        "params": "{}" | "" | { ... } | null
 *      }
 *
 *   B) Newer context wrapper:
 *      {
 *        "context": { "requestId": 1, "connectionId": 2, "appId": "com.example" },
 *        "origin": "org.rdk.AppGateway",
 *        "method": "device.name",
 *        "params": { ... } | "" | null
 *      }
 */
namespace JAppGatewayResolver {

namespace Version {
constexpr uint8_t Major = 1;
constexpr uint8_t Minor = 0;
constexpr uint8_t Patch = 0;
} // namespace Version

namespace {

class ContextData final : public Core::JSON::Container {
public:
    ContextData()
        : Core::JSON::Container()
        , RequestId(0)
        , ConnectionId(0)
        , AppId()
    {
        Add(_T("requestId"), &RequestId);
        Add(_T("connectionId"), &ConnectionId);
        Add(_T("appId"), &AppId);
    }

    Core::JSON::DecUInt32 RequestId;
    Core::JSON::DecUInt32 ConnectionId;
    Core::JSON::String AppId;
};

class ResolveRequestData final : public Core::JSON::Container {
public:
    ResolveRequestData()
        : Core::JSON::Container()
        , Context(false)
        , RequestId(0)
        , ConnectionId(0)
        , AppId()
        , Origin()
        , Method()
        , Params()
    {
        // Support both { "context": {...} } and top-level requestId/connectionId/appId.
        Add(_T("context"), &Context);

        Add(_T("requestId"), &RequestId);
        Add(_T("connectionId"), &ConnectionId);
        Add(_T("appId"), &AppId);

        Add(_T("origin"), &Origin);
        Add(_T("method"), &Method);

        // "params" can be string/object/null (tests cover empty-string and object forms).
        Add(_T("params"), &Params);
    }

    ContextData Context;

    Core::JSON::DecUInt32 RequestId;
    Core::JSON::DecUInt32 ConnectionId;
    Core::JSON::String AppId;

    Core::JSON::String Origin;
    Core::JSON::String Method;
    Core::JSON::Variant Params;
};

static bool ExtractContextFields(const ResolveRequestData& req,
                                 uint32_t& requestId,
                                 uint32_t& connectionId,
                                 string& appId)
{
    // Prefer nested context if present.
    const bool hasContext =
        req.Context.RequestId.IsSet() || req.Context.ConnectionId.IsSet() || req.Context.AppId.IsSet();

    if (hasContext) {
        if (!req.Context.RequestId.IsSet() || !req.Context.ConnectionId.IsSet() || !req.Context.AppId.IsSet()) {
            return false;
        }
        requestId = req.Context.RequestId.Value();
        connectionId = req.Context.ConnectionId.Value();
        appId = req.Context.AppId.Value();
        return !appId.empty();
    }

    // Fallback to top-level fields.
    if (!req.RequestId.IsSet() || !req.ConnectionId.IsSet() || !req.AppId.IsSet()) {
        return false;
    }
    requestId = req.RequestId.Value();
    connectionId = req.ConnectionId.Value();
    appId = req.AppId.Value();
    return !appId.empty();
}

static string NormalizeParamsToJsonText(const ResolveRequestData& req)
{
    // Missing/null params => treat as {} (params are optional in JSON-RPC).
    if (!req.Params.IsSet() || req.Params.IsNull()) {
        return _T("{}");
    }

    // If params is a STRING, interpret it as already JSON text (or empty => {}).
    if (req.Params.Content() == Core::JSON::Variant::type::STRING) {
        string raw = req.Params.Value(); // Value() is raw (no surrounding quotes)
        if (raw.empty()) {
            return _T("{}");
        }
        return raw;
    }

    // Otherwise stringify the JSON value (object/array/number/bool).
    string out;
    req.Params.ToString(out);
    if (out.empty()) {
        return _T("{}");
    }
    return out;
}

} // namespace

PUSH_WARNING(DISABLE_WARNING_UNUSED_FUNCTIONS)

static void Register(PluginHost::JSONRPC& module, IAppGatewayResolver* impl)
{
    ASSERT(impl != nullptr);

    module.RegisterVersion(_T("JAppGatewayResolver"), Version::Major, Version::Minor, Version::Patch);

    // Register "resolve" as a raw InvokeFunction so we can:
    //  - detect malformed JSON (FromString error)
    //  - support two request shapes used across L0 tests
    //  - normalize params consistently ("" => "{}", object => JSON string)
    module.Register(_T("resolve"),
        [impl](const Core::JSONRPC::Context& /*ctx*/,
               const string& /*designator*/,
               const string& parameters,
               string& response) -> uint32_t {
            ResolveRequestData req;
            Core::OptionalType<Core::JSON::Error> error;

            if (req.FromString(parameters, error) == false || error.IsSet() == true) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }

            // Validate required fields.
            if (!req.Origin.IsSet() || req.Origin.Value().empty()) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }
            if (!req.Method.IsSet() || req.Method.Value().empty()) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }

            uint32_t requestId = 0;
            uint32_t connectionId = 0;
            string appId;

            if (!ExtractContextFields(req, requestId, connectionId, appId)) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }

            const string paramsJson = NormalizeParamsToJsonText(req);

            GatewayContext gw;
            gw.requestId = requestId;
            gw.connectionId = connectionId;
            gw.appId = appId;

            string result;
            const uint32_t rc = impl->Resolve(gw, req.Origin.Value(), req.Method.Value(), paramsJson, result);

            response = result;
            return rc;
        });
}

static void Unregister(PluginHost::JSONRPC& module)
{
    // Unregister methods...
    module.Unregister(_T("resolve"));
}

POP_WARNING()

} // namespace JAppGatewayResolver

// Backwards-compat wrapper (some code uses Exchange::JAppGatewayResolver::Register())
struct JAppGatewayResolver {
    static void Register(PluginHost::JSONRPC& module, IAppGatewayResolver* impl)
    {
        JAppGatewayResolver::Register(module, impl);
    }
    static void Unregister(PluginHost::JSONRPC& module)
    {
        JAppGatewayResolver::Unregister(module);
    }
};

} // namespace Exchange
} // namespace WPEFramework
