#pragma once

#include "../IAppGateway.h"

#include <core/JSON.h>
#include <plugins/JSONRPC.h>

namespace WPEFramework {
namespace Exchange {

/*
 * Minimal JSON-RPC wrapper for IAppGatewayResolver used by plugin/AppGateway.cpp.
 *
 * In upstream builds this header is generated by Thunder's JsonGenerator.
 * In this repo we provide a small, test-focused implementation so L0 can:
 *  - Initialize successfully (register "resolve")
 *  - Invoke "resolve" via PluginHost::IDispatcher
 *  - Exercise bad-request paths deterministically
 *
 * Supported request shapes (both appear in this repoâ€™s tests):
 *   A) Legacy/top-level fields:
 *      {
 *        "requestId": 1,
 *        "connectionId": 2,
 *        "appId": "com.example",
 *        "origin": "org.rdk.AppGateway",
 *        "method": "device.name",
 *        "params": "{}" | "" | { ... } | null
 *      }
 *
 *   B) Newer context wrapper:
 *      {
 *        "context": { "requestId": 1, "connectionId": 2, "appId": "com.example" },
 *        "origin": "org.rdk.AppGateway",
 *        "method": "device.name",
 *        "params": { ... } | "" | null
 *      }
 *
 * NOTE:
 * AppGateway.cpp calls:
 *   Exchange::JAppGatewayResolver::Register(*this, mAppGateway);
 * so this header intentionally exposes a namespace `Exchange::JAppGatewayResolver`
 * with free functions `Register` and `Unregister`.
 */
namespace JAppGatewayResolver {

namespace Version {
constexpr uint8_t Major = 1;
constexpr uint8_t Minor = 0;
constexpr uint8_t Patch = 0;
} // namespace Version

namespace detail {

class ContextData final : public Core::JSON::Container {
public:
    ContextData()
        : Core::JSON::Container()
        , RequestId(0)
        , ConnectionId(0)
        , AppId()
    {
        Add(_T("requestId"), &RequestId);
        Add(_T("connectionId"), &ConnectionId);
        Add(_T("appId"), &AppId);
    }

    Core::JSON::DecUInt32 RequestId;
    Core::JSON::DecUInt32 ConnectionId;
    Core::JSON::String AppId;
};

class ResolveRequestData final : public Core::JSON::Container {
public:
    ResolveRequestData()
        : Core::JSON::Container()
        , Context()
        , RequestId(0)
        , ConnectionId(0)
        , AppId()
        , Origin()
        , Method()
        , Params()
    {
        // Support both { "context": {...} } and top-level requestId/connectionId/appId.
        Add(_T("context"), &Context);

        Add(_T("requestId"), &RequestId);
        Add(_T("connectionId"), &ConnectionId);
        Add(_T("appId"), &AppId);

        Add(_T("origin"), &Origin);
        Add(_T("method"), &Method);

        // "params" can be string/object/null (tests cover empty-string and object forms).
        Add(_T("params"), &Params);
    }

    ContextData Context;

    Core::JSON::DecUInt32 RequestId;
    Core::JSON::DecUInt32 ConnectionId;
    Core::JSON::String AppId;

    Core::JSON::String Origin;
    Core::JSON::String Method;
    Core::JSON::Variant Params;
};

static bool KeyPresent(const string& json, const char* keyWithQuotes)
{
    // Minimal/test-focused key presence check.
    // This is used to correctly accept boundary values like 0 where some JSON element
    // implementations may keep IsSet() false if the parsed value equals the default.
    return (json.find(keyWithQuotes) != string::npos);
}

static string TrimAsciiWhitespace(string s)
{
    const auto isSpace = [](const char c) -> bool {
        return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');
    };

    while (!s.empty() && isSpace(s.front())) {
        s.erase(s.begin());
    }
    while (!s.empty() && isSpace(s.back())) {
        s.pop_back();
    }
    return s;
}

static string NormalizeJsonStringValue(const string& input)
{
    // Thunder JSON element implementations are not perfectly consistent across versions:
    // in some cases Value() can be:
    //   - raw:                 com.example
    //   - JSON-fragment:       "com.example"
    //   - escaped JSON-string: \"com.example\"
    //
    // Normalize to a raw string for robust checks like empty-appId detection.
    string out = TrimAsciiWhitespace(input);

    // Unescape occurrences of \\\" -> \"
    for (;;) {
        const std::size_t pos = out.find("\\\"");
        if (pos == string::npos) {
            break;
        }
        out.replace(pos, 2, "\"");
    }

    out = TrimAsciiWhitespace(out);

    // Strip wrapping quotes if present.
    if (out.size() >= 2 && out.front() == '"' && out.back() == '"') {
        out = out.substr(1, out.size() - 2);
    }

    return TrimAsciiWhitespace(out);
}

static bool ExtractContextFields(const ResolveRequestData& req,
                                 const string& rawJson,
                                 uint32_t& requestId,
                                 uint32_t& connectionId,
                                 string& appId)
{
    // Decide whether "context" wrapper is intended.
    const bool contextMentioned =
        req.Context.RequestId.IsSet() || req.Context.ConnectionId.IsSet() || req.Context.AppId.IsSet() ||
        KeyPresent(rawJson, "\"context\"");

    auto requiredKeysPresent = [&rawJson]() -> bool {
        // NOTE: We intentionally accept keys present in nested objects as well. The L0 tests
        // include both top-level and "context" wrapper forms.
        return KeyPresent(rawJson, "\"requestId\"") &&
               KeyPresent(rawJson, "\"connectionId\"") &&
               KeyPresent(rawJson, "\"appId\"");
    };

    if (!requiredKeysPresent()) {
        return false;
    }

    if (contextMentioned) {
        requestId = req.Context.RequestId.Value();
        connectionId = req.Context.ConnectionId.Value();
        appId = NormalizeJsonStringValue(req.Context.AppId.Value());

        // If the request mentions "context" but context.{...} is empty/default (or appId empty),
        // fall back to top-level fields if present.
        if (!appId.empty()) {
            return true;
        }
    }

    // Fallback to top-level fields.
    requestId = req.RequestId.Value();
    connectionId = req.ConnectionId.Value();
    appId = NormalizeJsonStringValue(req.AppId.Value());
    return !appId.empty();
}

static string NormalizeParamsToJsonText(const ResolveRequestData& req)
{
    // Missing/null params => treat as {} (params are optional in JSON-RPC).
    if (!req.Params.IsSet() || req.Params.IsNull()) {
        return _T("{}");
    }

    // If params is a STRING, interpret it as already JSON text (or empty => {}).
    if (req.Params.Content() == Core::JSON::Variant::type::STRING) {
        string raw = NormalizeJsonStringValue(req.Params.Value());
        if (raw.empty()) {
            return _T("{}");
        }
        return raw;
    }

    // Otherwise (object/array/number/bool) the Variant already stores the JSON fragment text
    // in its underlying JSON::String base. Do NOT call Variant::ToString() as that symbol
    // is not available in some Thunder SDK builds (leads to undefined reference at link time).
    string out = TrimAsciiWhitespace(req.Params.Value());
    if (out.empty()) {
        return _T("{}");
    }

    // Defensive: if the fragment is accidentally quoted, normalize it.
    if (out.size() >= 2 && out.front() == '"' && out.back() == '"') {
        out = NormalizeJsonStringValue(out);
        if (out.empty()) {
            return _T("{}");
        }
    }

    return out;
}

} // namespace detail

PUSH_WARNING(DISABLE_WARNING_UNUSED_FUNCTIONS)

// PUBLIC_INTERFACE
inline void Register(PluginHost::JSONRPC& module, IAppGatewayResolver* impl)
{
    /** Register the minimal JSON-RPC method bindings for AppGatewayResolver ("resolve"). */
    ASSERT(impl != nullptr);

    // NOTE: In this repository's isolated L0 harness, IDispatcher::Invoke is used with
    // designator="" and method="resolve". Some Thunder SDK variants scope method registration
    // when RegisterVersion is called, which can make plain "resolve" appear as unknown.
    // Avoid version scoping here; the L0 tests focus on behavior rather than version metadata.

    // Register "resolve" as a raw InvokeFunction so we can:
    //  - detect malformed JSON (FromString error)
    //  - support two request shapes used across L0 tests
    //  - normalize params consistently ("" => "{}", object => JSON string)
    module.Register(_T("resolve"),
        [impl](const Core::JSONRPC::Context& /*ctx*/,
               const string& /*designator*/,
               const string& parameters,
               string& response) -> uint32_t {
            detail::ResolveRequestData req;
            Core::OptionalType<Core::JSON::Error> error;

            if (req.FromString(parameters, error) == false || error.IsSet() == true) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }

            // Validate required fields (post-normalization to handle quoted/escaped representations).
            const string origin = detail::NormalizeJsonStringValue(req.Origin.Value());
            const string method = detail::NormalizeJsonStringValue(req.Method.Value());

            if (!req.Origin.IsSet() || origin.empty()) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }
            if (!req.Method.IsSet() || method.empty()) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }

            uint32_t requestId = 0;
            uint32_t connectionId = 0;
            string appId;

            if (!detail::ExtractContextFields(req, parameters, requestId, connectionId, appId)) {
                response.clear();
                return Core::ERROR_BAD_REQUEST;
            }

            const string paramsJson = detail::NormalizeParamsToJsonText(req);

            GatewayContext gw;
            gw.requestId = requestId;
            gw.connectionId = connectionId;
            gw.appId = appId;

            string result;
            const uint32_t rc = impl->Resolve(gw, origin, method, paramsJson, result);

            response = result;
            return rc;
        });
}

// PUBLIC_INTERFACE
inline void Unregister(PluginHost::JSONRPC& module)
{
    /** Unregister the JSON-RPC method bindings for AppGatewayResolver ("resolve"). */
    module.Unregister(_T("resolve"));
}

POP_WARNING()

} // namespace JAppGatewayResolver

} // namespace Exchange
} // namespace WPEFramework
